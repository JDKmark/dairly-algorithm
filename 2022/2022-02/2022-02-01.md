# 617. 合并二叉树
给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始
示例:

```
输入：num = 14
输出：6
解释：
步骤 1) 14 是偶数，除以 2 得到 7 。
步骤 2） 7 是奇数，减 1 得到 6 。
步骤 3） 6 是偶数，除以 2 得到 3 。
步骤 4） 3 是奇数，减 1 得到 2 。
步骤 5） 2 是偶数，除以 2 得到 1 。
步骤 6） 1 是奇数，减 1 得到 0 。
```
时间：2022-01-31  
来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/merge-two-binary-trees

## 我的代码
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){
    if(root1 == NULL){
        return root2;
    }
    if(root2 == NULL){
        return root1;
    }

    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    root->val = root1->val + root2->val;
    root->left = mergeTrees(root1->left,root2->left);
    root->right = mergeTrees(root1->right,root2->right);
    return root;
}
```

## 理解
根据题意，对该过程进行模拟，判断是偶数就除2，是奇数就减一。
